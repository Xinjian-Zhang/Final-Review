Software Quality Lab - Design by Contract

### Exercise 1: Withdrawing Money I

We extend `Account`` with the following methods:

```python
class Account:
    def is_available(self, amount: Currency) -> Bool:
        """Return `True` when `self.balance` is at least `amount`"""
    
    ...
    
    def withdraw_checked(self, amount: Currency): -> Result:
        if self.is_available(amount):
            self.withdraw(amount)
            return Accepted
        else:
            return Rejected
```

1. Write a contract for the method is_available() .
   
2. By composing the contracts for is_available() and withdraw() , explain why withdraw_checked() is safe to call without any preconditions

----

    ### Exercise 2: Track Signaling I

    Consider the following class implementing railway signaling on a track segment
    between stations Tondi and Järve:

    ```python

    type Signal = Halt | Clear
    class Segment:
        track: Occupied | Free
        tondi: Signal
        järve: Signal
    def enter_tondi(self): ...
    def exited_järve(self): ...
    ```

    When the signal at one of the stations shows Clear it means that the track is Free, and it is safe to enter from that station.

    1. Write pre- and postconditions for. . .

    1.1 enter_tondi(): Set signals to allow a train to enter the segment from Tondi, marking the track as Occupied.

    1.2 exited_järve(): Record that a train has left the segment towards Järve and that
    the track is now Free, setting signals accordingly.

    2. Define an invariant for the class Segment.


